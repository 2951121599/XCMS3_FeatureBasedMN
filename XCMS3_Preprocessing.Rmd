## Install required packages

Note: This script is optimized for the latest R version (>3.6). Be sure to get
the most recent version of R before running. The code below installs the
required packages and all needed dependencies. Note: You don't have to run this
chunk if the packages are already installed.

```{r, eval = FALSE, message = FALSE}
if (!requireNamespace("BiocManager"))
    install.packages("BiocManager")
BiocManager::install(c("xcms", "CAMERA"))
```

## Preprocess your data using XCMS3 and export data files for feature-based molecular networking through GNPS

To follow this example tutorial, download the folder named
*peak/AMG_Plant_subset* from:
[here](https://massive.ucsd.edu/ProteoSAFe/dataset.jsp?task=de2d18fd91804785bce8c225cc94a444)

Note that the settings for `xcms` used in this tutorial were not optimized,
specifically the alignment based on the default *obiwarp* parameters might
perform a little to strong retention time adjustment.
For more information on optimization of the parameters see the [xcms vignette](https://bioconductor.org/packages/release/bioc/vignettes/xcms/inst/doc/xcms.html)
or the [LC-MS data pre-processing with xcms](https://github.com/jorainer/metabolomics2018) workshop.

Load required libraries and utility functions for GNPS export.

```{r, message = FALSE}
library(xcms)
source("https://raw.githubusercontent.com/jorainer/xcms-gnps-tools/master/customFunctions.R")
```

Use socket based parallel processing on Windows systems. The number (`4`)
defines the number of parallel tasks. Adapt this setting to the number of CPUs
available on your system. Also note that it is usually better to not use all
CPUs of a system as a) during the analysis the MS data has to be imported from
the original mzML/mzXML/CDF files and it will thus be limited by the I/O of the
hard disks and b) the computer needs to have enough memory to load the complete
MS data of as many raw data files than there are parallel jobs.

```{r}
if (.Platform$OS.type == "unix") {
  register(bpstart(MulticoreParam(4)))
} else {
  register(bpstart(SnowParam(4)))
} 
```

### Load data

Load all *.mzXML* files and define sample grouping. Note that for this example
we assign all samples to the same group. This should be changed according to the
experimental setup.

```{r}
mzMLfiles <- paste0('AMG_Plant_subset/',
                    list.files(path = 'AMG_Plant_subset/',
                               pattern = ".mzXML$", recursive = TRUE))
s_groups <- rep("sample", length(mzMLfiles))
pheno <- data.frame(sample_name = sub(basename(mzMLfiles), pattern = ".mzML",replacement = "", fixed = TRUE),
                    sample_group = s_groups, stringsAsFactors = FALSE)
```

```{r}
head(pheno)
```

Read all raw data (which includes MS1 and MS2 spectra).

```{r}
rawData <- readMSData(mzMLfiles, centroided. = TRUE, mode = "onDisk",
                      pdata = new("NAnnotatedDataFrame", pheno))
```

Create a base peak chromatogram (BPC) for visual inspection.

```{r, fig.width = 12, fig.height = 6, fig.cap = "Base peak chromatogram."}
bpis <- chromatogram(rawData, aggregationFun = "max")
plot(bpis)
```

### Peak picking

Define settings for the centWave peak detection. As mentioned in the
introduction, these settings should always be adapted to the analyzed data set.

```{r}
cwp <- CentWaveParam(snthresh = 5, noise = 1000, peakwidth = c(3, 30), ppm = 20)
```

Perform the chromatographic peak detection using *centWave*.

```{r, warning = FALSE, message = FALSE}
processedData <- findChromPeaks(rawData, param = cwp)
```

Get an overview of the detected peaks, using a heatmap which represents the
number of peaks detected for each file along the retention time range.
1
```{r, fig.width = 10, fig.height = 6}
plotChromPeakImage(processedData, binSize = 10) 
```

### Retention time alignment

Do an *obiwarp*-based alignment using the default settings (ideally adapt
settings to the analyzed data set).

```{r, message = FALSE, warning = FALSE}
processedData <- adjustRtime(processedData, param = ObiwarpParam())
```

Plot the difference between adjusted and raw retention times.

```{r, fig.width = 12, fig.height = 6}
plotAdjustedRtime(processedData)
```


### Peak grouping

Define the parameters for the *peak density*-based peak grouping (correspondence
analysis).

```{r, message = FALSE, warning = FALSE}
pdp <- PeakDensityParam(sampleGroups = processedData$sample_group,
                        minFraction = 0.10)
processedData <- groupChromPeaks(processedData, param = pdp) 
```

### Gap filling

Fill-in missing peaks. Peak detection might have failed for some features in
some samples. The `fillChromPeaks` function allows to integrate for such cases
all signal in the respective m/z - retention time range. Below we first define
the median width of identified chromatographic peaks in retention time dimension
and use this as parameter `fixedRt` for the `fillChromPeaks`.

```{r, message = FALSE, warning = FALSE}
medWidth <- median(chromPeaks(processedData)[, "rtmax"] -
                   chromPeaks(processedData)[, "rtmin"])
## fill missing peaks
processed_Data <- fillChromPeaks(
    processedData, param = FillChromPeaksParam(fixedRt = medWidth))

```

### Export data

#### export MS1 and MS2 features

Below we use the `featureSpectra` function to extract all MS2 spectra with their
precursor m/z being within the m/z range of a feature/peak and their retention
time within the rt range of the same feature/peak. Zero-intensity
values are removed from each spectrum with the `clean` function, and
subsequently processed into the expected format using the `formatSpectraForGNPS`
function.

```{r}
## export the individual spectra into a .mgf file
filteredMs2Spectra <- featureSpectra(processedData, return.type = "Spectra")
filteredMs2Spectra <- clean(filteredMs2Spectra, all = TRUE)
filteredMs2Spectra <- formatSpectraForGNPS(filteredMs2Spectra)
```

The extracted MS2 spectra are saved as *ms2spectra_all.mgf* file. This file can
for example be used to do *in silico* structure prediction through
[SIRIUS+CSI:FingerID](https://bio.informatik.uni-jena.de/software/sirius/).

```{r}
writeMgfData(filteredMs2Spectra, "ms2spectra_all.mgf")
```

Export peak area quantification table. To this end we first extract the *feature
definitions* (i.e. the m/z and retention time ranges and other metadata for all
defined features in the data set) and then the integrated peak areas (with the
`featureValues` function). This peak area quantification table contains features
and respective per sample peak areas in columns. The combined data is then saved
to the file *xcms_all.txt*. Note that it is now also possible to use the entire
feature table in the FBMN workflow.

```{r}
## get data
featuresDef <- featureDefinitions(processedData)
featuresIntensities <- featureValues(processedData, value = "into")

## generate data table
dataTable <- merge(featuresDef, featuresIntensities, by = 0, all = TRUE)
dataTable <- dataTable[, !(colnames(dataTable) %in% c("peakidx"))]
```

```{r}
head(dataTable)
```

```{r}
write.table(dataTable, "xcms_all.txt", sep = "\t", quote = FALSE, 
            row.names = FALSE)
```

### CAMERA annotation of adducts and isotopes

Note: the CAMERA package supports objects of class `xcmsSet`, which were the
outputs of the *old* version of xcms. The newer `XCMSnExp` object can however be
converted to an `xcmsSet` object with the `as(object, "xcmsSet")`, which does
however not support conversion of objects with MS level > 1 data. Thus we use
the `filterMsLevel` function on the result object to restrict the data in the
object to MS level 1 prior to the conversion.

```{r message = FALSE}
library(CAMERA)
xset <- as(filterMsLevel(processedData, msLevel = 1L), "xcmsSet")
```

With the conversion we lost also the sample group assignment which we have to
manually add.

```{r message = FALSE}
sampclass(xset) <- s_groups
```

Create and `xsAnnotate` object named `xsa` extracting the peak table from the 
`xcmsSet` object named `xset`:
```{r message = FALSE}
xsa <- xsAnnotate(xset, 
                  polarity = "positive" # or "negative"
                  )   
```

The following worflow can be divided in 2 big steps: (1) feature grouping in 
pseudospectras; and (2) annotate the ion species.  

The first step has the aim of group the peaks occurring from the same 
metabolite. For that, first of all we are going to group peaks of the 
`xsAnnotate` object (`xsa`) according to the RT:
```{r message = FALSE}
xsaF <- groupFWHM(
  xsa, 
  sigma = 6, 
  perfwhm = 1 # define the window width 
              # (it depends on RT variation: put a higher value if RT varies)
  ) 
```

In this example, this step has generated 283 pseudospectra.  

Then, we are going to verify grouping with peakshape correlation of features 
clustered in the same pseudospectra group (in order to separate co-eluting 
metabolites):
```{r}
xsaC <- groupCorr(
                  xsaF,
                  cor_eic_th = 0.6, # if the correlation value between 2 peaks 
                  # is higher than this threshold, they will stay in the group, 
                  # otherwise they will be separated
                  pval = 0.05,
                  graphMethod = "hcs",
                  calcCiS = TRUE,  # Calculate correlation inside samples
                  calcCaS = FALSE, # Calculate correlation accross samples
                  calcIso = FALSE  # Include isotope detection information 
                                   # for graph clustering
                  )
```
This step has seperated our 283 pseudospectra into 2689.

Now we are going to deal with the second big step of CAMERA workflow: 
annotation of isotopes and adducts within pseudospectra-groups:
```{r}
xsaFI <- findIsotopes( # annotate isotopes according to relation 
                       # between features (C12/C13)
                      xsaC,
                      maxcharge = 2, # max. number of the isotope charge
                      maxiso = 3,    # max. number of the isotope peaks
                      minfrac = 0.5,
                      ppm = 10,
                      intval="maxo"  
                    # xcms reports 3 different intensity values for each peak: 
                    # (1) maxo - maximum peak intensity; 
                    # (2) into - integrated peak intensity; 
                    # (3) intb - integrated peak intensity (baseline corrected)
                      )
xsaFA <- findAdducts( # annotate adducts and fragments
                     xsaFI,
                     polarity="positive", # or "negative"
                     max_peaks = 100,
                     multiplier = 3, # highest number of allowed clusterion
                     ppm = 10
                     )
```

Create a CAMERA annotated peak list:
```{r}
peaklist <- getPeaklist(xsaFA)
```
CAMERA annotations are added in the last columns (n=3) of the data frame.  
The column `pcgroup` shows the result of the peak aggrupation: features with the 
same value are supposed to belong to the same metabolite.   

Let's graphically check the CAMERA output. With the function `plotEICs` we can 
visualize the raw data, and with the function `plotPsSpectrum` we can plot all 
peaks of a pseudospectrum:
```{r}
plotEICs(      # plot the EICs of all peaks from one pseudospectrum
  xsaFA, 
  pspec = 120, # specify which pseudospectrum we want to plot
  maxlabel = 5 # How many m/z labels to print 
  )

#xsaFA@sample = 1
#plotPsSpectrum(xsaFA, pspec = 5) # This should print a typical m/z plot, with 
# labelled annotated peaks (but I cannot plot it since I'm getting different 
# errors. The first one can be solved previously executing "xsaFA@sample = 1" or 
# adding the argument "sample = c(1:n), with n = number of samples" in the 
# function "xsAnnotate")
```

Some times CAMERA is grouping features of different co-eluting metabolites. 
It can be detected if features from the same group have different peak shapes:
```{r}
plotEICs(xsaFA, maxlabel = 5, pspec = 26)
```


STOP HERE.

### Old stuff

xcms preprocessing of filtered MS1 data.

```{r}
rawDataMS1 <- filterMsLevel(rawData, msLevel = 1L)
xs1 <- findChromPeaks(rawDataMS1, param = cwp)
ret1 <- adjustRtime(xs1, 
                    param = ObiwarpParam()
                    )
gret1 <- groupChromPeaks(ret1, param = pdp)
fill1 <- fillChromPeaks(gret1, param = FillChromPeaksParam(fixedRt = medWidth))
```

Transform the XCMSnExp in xcmsSet object to support CAMERA annotation.

```{r}
xset <- as(fill1, "xcmsSet")
```

Create a xsAnnotate object.

```{r}
xsa <- xsAnnotate(xset)
```

Grouping of co-eluted peaks based on rt.

```{r}
xsaF <- groupFWHM(
                  xsa,
                  sigma = 6,
                  perfwhm = 1
                  )
```                  

Check grouping.

```{r}
xsaC <- groupCorr(
                  xsaF,
                  cor_eic_th = 0.6,
                  pval = 0.05,
                  graphMethod = "hcs",
                  calcCiS = TRUE,
                  calcIso = FALSE,
                  calcCaS=FALSE
                  )
```                  

CAMERA annotation of isotopes and adducts

```{r}
xsaFI <- findIsotopes(
                      xsaC,
                      maxcharge = 2,
                      maxiso = 3,
                      minfrac = 0.5
                      )
xsaFA <- findAdducts(
                     xsaFI,
                     polarity="positive", # or "negative"
                     max_peaks = 100,
                     multiplier = 3
                     )
```

Create a CAMERA annotated peak list.

```{r}
peaklist <- getPeaklist(xsaFA)
```

Bind tha CAMERA nnotated peak list with the previously obtained peak aera quantification table.

```{r}
annotated_dataTable <- cbind(
                                 dataTable,
                                 peaklist[,c((ncol(peaklist)-2):ncol(peaklist))]
                                 )
```

Export peak area quantification table and CAMERA annotation of adducts and isotopes.  

```{r}
write.table(annotated_dataTable, "xcms_camera_all.txt", sep = "\t", quote = FALSE, row.names = FALSE)
```

#### Export MS2 features only

The `filteredMs2Spectra` contains all MS2 spectra with their precursor m/z
within the feature's m/z range and a retention time that is within the retention
time of the chromatographic peak/feature. We thus have multiple MS2 spectra for
each feature (also from each sample). Metadata column `"feature_id"` indicates
to which feature a MS2 spectrum belongs:

```{r}
filteredMs2Spectra
```

We next select a single MS2 spectrum for each feature and export this reduced
set also as an .mgf file. We use the `combineSpectra` function on the list of
spectra and specify with `fcol = "feature_id"` how the spectra are grouped
(i.e. all spectra with the same feature id are processed together). On the set
of spectra of the same feature we apply the `maxTic` function that simply
returns the spectrum with the largest sum of intensities. We thus select with
the code below the spectrum with the largest total signal as the
*representative* MS2 spectrum for each feature.

```{r}
## Select for each feature the Spectrum2 with the largest TIC.
filteredMs2Spectra_maxTic <- combineSpectra(filteredMs2Spectra,
                                            fcol = "feature_id",
                                            method = maxTic)
```

Next we export the data to a file which can then be submitted to GNPS [feature-based
molecular
networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/).

```{r}
writeMgfData(filteredMs2Spectra_maxTic, "ms2spectra_maxTic.mgf")
```

At last we subset the peak area quantification table to features for which we
have also an MS2 spectrum and export this to the *xcms_onlyMS2.txt* file. This
file can be submitted to GNPS [feature-based molecular
networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/):

```{r}
## filter data table to contain only peaks with MSMS DF[ , !(names(DF) %in% drops)]
filteredDataTable <- dataTable[which(
    dataTable$Row.names %in% filteredMs2Spectra@elementMetadata$feature_id),]
```

```{r}
head(filteredDataTable)
```

```{r}
write.table(filteredDataTable, "xcms_onlyMS2.txt", sep = "\t", quote = FALSE, row.names = FALSE)
```

#### Export MS2 consensus spectra

Alternatively, instead of selecting the spectrum with the largest total signal
as representative MS2 spectrum for each feature, we can create a *consensus MS2
spectrum*. A consensus MS2 spectrum can for example be created by combining all
MS2 spectra for a feature into a single spectrum that contains peaks present in
the majority of spectra. Note however that this feature is experimental at
present.

To this end we can use the `consensusSpectrum` function in combination with the
`combineSpectra` function. The parameter `minProp` defines the mimimal
proportion of spectra in which a peak has to be present in order for it to be
added to the consensus spectrum (0.8 -> 80% of spectra). The parameters `mzd`
and `ppm` allow to define how to group peaks between spectra with `mzd` being a
fixed, constant value and all peaks between spectra with a difference in their
m/z < `mzd` are combined into the final mass peak in the consensus
spectrum. Finally, the parameter `ppm` allows to perform an m/z dependent
grouping of mass peaks, i.e. mass peaks with a difference in their m/z smaller
than `ppm` are combined.

For more details see the documentation of the
[consensusSpectrum](https://rdrr.io/bioc/MSnbase/man/consensusSpectrum.html)
function in the MSnbase R package.

```{r, message = FALSE, warning = FALSE}
filteredMs2Spectra_consensus <- combineSpectra(
    filteredMs2Spectra, fcol = "feature_id", method = consensusSpectrum,
    mzd = 0, minProp = 0.8, ppm = 10)

writeMgfData(filteredMs2Spectra_consensus, "ms2spectra_consensus.mgf")
```

Analogously we subset the peak area quantification table to features for which
we have an MS2 consensus spectrum and export this to the *xcms_consensusMS2.txt*
file. This file can be submitted to GNPS [feature-based molecular
networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/):

```{r}
consensusDataTable <- dataTable[which(dataTable$Row.names %in%
                                      filteredMs2Spectra_consensus@elementMetadata$feature_id),]
head(consensusDataTable)
```

```{r}
write.table(consensusDataTable, "xcms_consensusMS2.txt",
            sep = "\t", quote = FALSE, row.names = FALSE)
```

### Session information

```{r}
sessionInfo()
```
